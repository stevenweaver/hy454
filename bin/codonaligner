#!/usr/bin/env python3.2

import argparse, sys

from json import dump as json_dump
from os.path import exists

from hy454 import align_to_refseq, to_positional
from Bio import SeqIO, AlignIO


_refseqs = {}


def positional_write(msa, fh):
    json_dump(to_positional(msa), fh, separators=(',', ':'))
    fh.write('\n')


def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    parser = argparse.ArgumentParser(
        description='align sequences to a reference using a codon alignment algorithm, returning FASTA by default'
    )
    parser.add_argument(
        'input',
        metavar='FASTAFILE',
        type=argparse.FileType('r'),
        help='unaligned FASTA file'
    )
    parser.add_argument(
        '-r', '--reference',
        dest='reference',
        choices=_refseqs.keys(),
        help='use a provided default reference sequence'
    )
    parser.add_argument(
        '-p', '--positional',
        dest='writefunc',
        action='store_const',
        const=positional_write,
        default=lambda msa, fh: AlignIO.write(msa, fh, 'fasta'),
        help='return JSON-formatted reference-relative codon positional format'
    )
    parser.add_argument(
        '-o', '--output',
        type=argparse.FileType('w'),
        help='save alignment to OUTPUT'
    )

    args = None
    try:
        args = parser.parse_args(argv)

        seqrecords = [r for r in SeqIO.parse(args.input, 'fasta')]

        if args.reference is None:
            refseq = seqrecords.pop(0)
        else:
            refseq = _refseqs[args.reference]

        msa = align_to_refseq(refseq, seqrecords)

        if args.output is not None:
            args.writefunc(msa, args.output)
        else:
            args.writefunc(msa, sys.stdout)
    finally:
        if args is not None:
            args.input.close()
            if args.output is not None:
                args.output.close()

    return 0


if __name__ == '__main__':
    sys.exit(main())
