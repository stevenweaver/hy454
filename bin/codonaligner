#!/usr/bin/env python3.2

import argparse, sys

from json import dump as json_dump
from os.path import exists

from Bio import SeqIO, AlignIO

from BioExt import hxb2, nl4_3

from hy454 import align_to_refseq, to_positional


_refseqs = {
    'HXB2_env': hxb2.env,
    'HXB2_gag': hxb2.gag,
    'HXB2_int': hxb2.int,
    'HXB2_nef': hxb2.nef,
    'HXB2_pol': hxb2.pol,
    'HXB2_pr': hxb2.pr,
    'HXB2_prrt': hxb2.prrt,
    'HXB2_rev': hxb2.rev,
    'HXB2_rt': hxb2.rt,
    'HXB2_tat': hxb2.tat,
    'HXB2_vif': hxb2.vif,
    'HXB2_vpr': hxb2.vpr,
    'HXB2_vpu': hxb2.vpu,
    'NL4-3_prrt': nl4_3.prrt
}


def positional_write(msa, fh):
    json_dump(to_positional(msa), fh, separators=(',', ':'))
    fh.write('\n')


def main(infile=sys.stdout, reference=None, outfile=None, positional=False, homology = None, dropped = None):

    if outfile is None:
        outfile = sys.stdout

    if positional is True:
        write = positional_write
    else:
        write = lambda msa, fh: AlignIO.write(msa, fh, 'fasta')

    if homology is None:
        homology = 0.6
        
    seqrecords = [r for r in SeqIO.parse(infile, 'fasta')]

    if reference is None:
        refseq = seqrecords.pop(0)
    else:
        refseq = _refseqs[args.reference].load()

    msa, dropped_seqs = align_to_refseq(refseq, seqrecords, homology_filter = homology)

    write(msa, outfile)
        
    if dropped is not None and len (dropped_seqs) > 0:
    	SeqIO.write(dropped_seqs, dropped, 'fasta')

    return 0



if __name__ == '__main__':

    def check_homology_range (string):
        try:
            value = float (string)
            if value < 0.0 or value > 1.0:
                raise argparse.ArgumentTypeError("%s is not a value in [0,1]" % string)
            return value
        except ValueError as e:
            raise argparse.ArgumentTypeError("%s must be a floating point number" % string)

    parser = argparse.ArgumentParser(
        description='align sequences to a reference using a codon alignment algorithm, returning FASTA by default'
    )
    parser.add_argument(
        'input',
        metavar='FASTAFILE',
        type=argparse.FileType('r'),
        help='unaligned FASTA file'
    )
    parser.add_argument(
        '-r', '--reference',
        choices=sorted(_refseqs.keys()),
        help='use a provided default reference sequence'
    )
    parser.add_argument(
        '-p', '--positional',
        action='store_true',
        help='return JSON-formatted reference-relative codon positional format'
    )
    parser.add_argument(
        '-o', '--output',
        type=argparse.FileType('w'),
        help='save alignment to OUTPUT'
    )

    parser.add_argument(
        '-m', '--homology',
        type=check_homology_range,
        help='discard sequences that are insufficiently homologous to the reference sequence [default value = 0.6]'
    )

    parser.add_argument(
        '-d', '--dropped',
        type=argparse.FileType('w'),
        help='write unaligned sequences which failed the homology screen here (pass-through) [default = sequences are not written]'
    )

    args = None
    retcode = -1
    try:
        args = parser.parse_args()
        retcode = main(args.input, args.reference, args.output, args.positional, args.homology, args.dropped)
    finally:
        if args is not None:
            if not args.input in (None, sys.stdin):
                args.input.close()
            if not args.output in (None, sys.stdout):
                args.output.close()
    sys.exit(retcode)
